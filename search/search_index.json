{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Argufy Inspection-based command line interface (CLI) written in Python. Overview Argufy is built around Argparse to create CLI's. First, inspection is used to determine each command and arguments to be created. Next, docstrings are parsed to fill in any additional settings. Motivation This parser was created because there wasn't a parser that built on what I believed are some real strenths of Python. Inspection is a really powerfull tool and I wanted a CLI that would be updated with minimal effort. Argufy does this by building CLI's from the functions directly. It then parses docstrings to fill in any additional content to create a parser. In short, the more code-complete your application is the more complete the CLI. Design Principles Design Choices Alternatives There are multiple alternatives such as Click and Docpopt. These are great options but each have their own trade-offs. Argparse Argparse is a great parser with many built-in features. But, it is an additional layer of complexity that needs to be managed when developing with it. Click Click is a great alternative and is widely used. It is also part of the Pallets Projects suite of tools. Click is a decorator based CLI parser. Decorators are easy and convenient but prevent inspection from being used without a performance and capability hit. It also requires that your code be wrapped with the decorators. This is less usefull when needing the tools to function also as a library. Docopt Docopt is another great option for CLI parsers and is similar in scope to Argufy. It works by parsing docstrings directly in the main module of an applications. A CLI is created by adding the syntax directly into docstrings. Updates to an application still requires that the CLI also be updated independently.","title":"Overview"},{"location":"#welcome-to-argufy","text":"Inspection-based command line interface (CLI) written in Python.","title":"Welcome to Argufy"},{"location":"#overview","text":"Argufy is built around Argparse to create CLI's. First, inspection is used to determine each command and arguments to be created. Next, docstrings are parsed to fill in any additional settings.","title":"Overview"},{"location":"#motivation","text":"This parser was created because there wasn't a parser that built on what I believed are some real strenths of Python. Inspection is a really powerfull tool and I wanted a CLI that would be updated with minimal effort. Argufy does this by building CLI's from the functions directly. It then parses docstrings to fill in any additional content to create a parser. In short, the more code-complete your application is the more complete the CLI.","title":"Motivation"},{"location":"#design-principles","text":"","title":"Design Principles"},{"location":"#design-choices","text":"","title":"Design Choices"},{"location":"#alternatives","text":"There are multiple alternatives such as Click and Docpopt. These are great options but each have their own trade-offs. Argparse Argparse is a great parser with many built-in features. But, it is an additional layer of complexity that needs to be managed when developing with it. Click Click is a great alternative and is widely used. It is also part of the Pallets Projects suite of tools. Click is a decorator based CLI parser. Decorators are easy and convenient but prevent inspection from being used without a performance and capability hit. It also requires that your code be wrapped with the decorators. This is less usefull when needing the tools to function also as a library. Docopt Docopt is another great option for CLI parsers and is similar in scope to Argufy. It works by parsing docstrings directly in the main module of an applications. A CLI is created by adding the syntax directly into docstrings. Updates to an application still requires that the CLI also be updated independently.","title":"Alternatives"},{"location":"commands/","text":"Commands Overview The commands module takes a module as an argument and inspects it for functions. The results are then used to populate CLI commands. It is different from the subcommands module in that the module name isn't used as a command itself. This command is usefull either for all-in-modules or a module that is holding functions that combine an applications parts into a CLI. Convert Module to CLI To create a CLI start with a module of functions to convert. def example_bool(bool_check = False): print(bool_check) def example_choice(choice_check = 'A'): print(choice_check) Creating a parser Next create a parser to from argufy import Parser from . import cli def main(): '''Do main function for a cli module.''' parser = Parser() parser.add_commands(cli) parser.dispatch() if __name__ == '__main__': main() Pack loading order Using __main__ vs __init__ for CLI instances.","title":"Commands"},{"location":"commands/#commands","text":"","title":"Commands"},{"location":"commands/#overview","text":"The commands module takes a module as an argument and inspects it for functions. The results are then used to populate CLI commands. It is different from the subcommands module in that the module name isn't used as a command itself. This command is usefull either for all-in-modules or a module that is holding functions that combine an applications parts into a CLI.","title":"Overview"},{"location":"commands/#convert-module-to-cli","text":"To create a CLI start with a module of functions to convert. def example_bool(bool_check = False): print(bool_check) def example_choice(choice_check = 'A'): print(choice_check)","title":"Convert Module to CLI"},{"location":"commands/#creating-a-parser","text":"Next create a parser to from argufy import Parser from . import cli def main(): '''Do main function for a cli module.''' parser = Parser() parser.add_commands(cli) parser.dispatch() if __name__ == '__main__': main()","title":"Creating a parser"},{"location":"commands/#pack-loading-order","text":"Using __main__ vs __init__ for CLI instances.","title":"Pack loading order"},{"location":"docstrings/","text":"","title":"Docstrings"},{"location":"getting-started/","text":"Getting Started The document is intended to help quickly get started using Argufy. Installation pip install argufy Convert Module to CLI To create a CLI start with a module of functions to convert. def example_bool(bool_check = False): print(bool_check) Creating a parser Next create a parser to from argufy import Parser from . import cli def main(): parser = Parser() parser.add_commands(cli) parser.dispatch() if __name__ == '__main__': main() Running Commands python -m check.py Example help message usage: argufy [-h] {example-bool,example-choice} ... Argufier is an inspection based CLI parser. positional arguments: {example-bool} example-bool optional arguments: -h, --help show this help message and exit Example command with output $ python -m check.py example-bool --bool-check=True True","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"The document is intended to help quickly get started using Argufy.","title":"Getting Started"},{"location":"getting-started/#installation","text":"pip install argufy","title":"Installation"},{"location":"getting-started/#convert-module-to-cli","text":"To create a CLI start with a module of functions to convert. def example_bool(bool_check = False): print(bool_check)","title":"Convert Module to CLI"},{"location":"getting-started/#creating-a-parser","text":"Next create a parser to from argufy import Parser from . import cli def main(): parser = Parser() parser.add_commands(cli) parser.dispatch() if __name__ == '__main__': main()","title":"Creating a parser"},{"location":"getting-started/#running-commands","text":"python -m check.py","title":"Running Commands"},{"location":"getting-started/#example-help-message","text":"usage: argufy [-h] {example-bool,example-choice} ... Argufier is an inspection based CLI parser. positional arguments: {example-bool} example-bool optional arguments: -h, --help show this help message and exit","title":"Example help message"},{"location":"getting-started/#example-command-with-output","text":"$ python -m check.py example-bool --bool-check=True True","title":"Example command with output"},{"location":"roadmap/","text":"Roadmap The intent is to be able to allow parsers to be built from any object a developer wishes. Note Currently, only methods inspection is fully supported. Features Generate commands from functions within modules Dispatch commands arguments to functions Create arguments from function Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from modules Create subcommand arguments from module arguments Set module arguments Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from objects Dispatch commands arguments to functions Create subcommand arguments from instance arguments Set instance arguments Type Hints Defaults Help Types Docstrings Defaults Help Types","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"The intent is to be able to allow parsers to be built from any object a developer wishes. Note Currently, only methods inspection is fully supported.","title":"Roadmap"},{"location":"roadmap/#features","text":"Generate commands from functions within modules Dispatch commands arguments to functions Create arguments from function Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from modules Create subcommand arguments from module arguments Set module arguments Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from objects Dispatch commands arguments to functions Create subcommand arguments from instance arguments Set instance arguments Type Hints Defaults Help Types Docstrings Defaults Help Types","title":"Features"},{"location":"subcommands/","text":"","title":"Subcommands"},{"location":"type-hints/","text":"","title":"Type hints"},{"location":"development/argument/","text":"Arguments for inspection based CLI parser. Argument Represent argparse arguments. action: str property writable Get argparse argument action. choices: List [ str ] property writable Get argparse argument choices. default: Any property writable Get argparse argument default. help: str property writable Get argparse command/argument help message. metavar: str property writable Get argparse argument metavar. name: List [ str ] property writable Get argparse command/argument name. nargs: Union [ int , str ] property writable Get argparse argument nargs. type: Any property writable Get argparse argument type. __init__ ( self , parameters , docstring ) special Initialize argparse argument. Source code in argufy/argument.py def __init__ ( self , parameters : inspect . Parameter , docstring : DocstringParam , ) -> None : '''Initialize argparse argument.''' # self.attributes: Dict[Any, Any] = {} self . default = parameters . default self . name = parameters . name . replace ( '_' , '-' ) # type: ignore if parameters . annotation != inspect . _empty : # type: ignore # if typing.get_origin(parameters.annotation) is Union: if hasattr ( parameters . annotation , '__origin__' ): annotation = typing . get_args ( parameters . annotation ) for x in annotation : if x is None : self . nargs = '?' else : self . type = x else : self . type = parameters . annotation elif docstring and docstring . type_name : if ',' in docstring . type_name : for arg in docstring . type_name . split ( ',' , 1 ): if not hasattr ( self , 'type' ): # NOTE: Limit input that eval will parse if arg in types : self . type = ( literal_eval ( arg ) if arg != 'str' else str ) if arg . lower () == 'optional' and not hasattr ( self , 'default' ): self . default = None # TODO: tighten regex if re . search ( r '^\\s*\\{.*\\}\\s*$' , arg ): self . choices = literal_eval ( arg . strip ()) if not hasattr ( self , 'type' ): # NOTE: Limit input that eval will parse if docstring . type_name in types : self . type = eval ( docstring . type_name ) # nosec elif self . default is not None : self . type = type ( self . default ) # if hasattr(self, 'type'): # self.metavar = (self.type.__name__) if docstring : self . help = docstring . description","title":"Argument"},{"location":"development/argument/#argufy.argument","text":"Arguments for inspection based CLI parser.","title":"argufy.argument"},{"location":"development/argument/#argufy.argument.Argument","text":"Represent argparse arguments.","title":"Argument"},{"location":"development/argument/#argufy.argument.Argument.action","text":"Get argparse argument action.","title":"action"},{"location":"development/argument/#argufy.argument.Argument.choices","text":"Get argparse argument choices.","title":"choices"},{"location":"development/argument/#argufy.argument.Argument.default","text":"Get argparse argument default.","title":"default"},{"location":"development/argument/#argufy.argument.Argument.help","text":"Get argparse command/argument help message.","title":"help"},{"location":"development/argument/#argufy.argument.Argument.metavar","text":"Get argparse argument metavar.","title":"metavar"},{"location":"development/argument/#argufy.argument.Argument.name","text":"Get argparse command/argument name.","title":"name"},{"location":"development/argument/#argufy.argument.Argument.nargs","text":"Get argparse argument nargs.","title":"nargs"},{"location":"development/argument/#argufy.argument.Argument.type","text":"Get argparse argument type.","title":"type"},{"location":"development/argument/#argufy.argument.Argument.__init__","text":"Initialize argparse argument. Source code in argufy/argument.py def __init__ ( self , parameters : inspect . Parameter , docstring : DocstringParam , ) -> None : '''Initialize argparse argument.''' # self.attributes: Dict[Any, Any] = {} self . default = parameters . default self . name = parameters . name . replace ( '_' , '-' ) # type: ignore if parameters . annotation != inspect . _empty : # type: ignore # if typing.get_origin(parameters.annotation) is Union: if hasattr ( parameters . annotation , '__origin__' ): annotation = typing . get_args ( parameters . annotation ) for x in annotation : if x is None : self . nargs = '?' else : self . type = x else : self . type = parameters . annotation elif docstring and docstring . type_name : if ',' in docstring . type_name : for arg in docstring . type_name . split ( ',' , 1 ): if not hasattr ( self , 'type' ): # NOTE: Limit input that eval will parse if arg in types : self . type = ( literal_eval ( arg ) if arg != 'str' else str ) if arg . lower () == 'optional' and not hasattr ( self , 'default' ): self . default = None # TODO: tighten regex if re . search ( r '^\\s*\\{.*\\}\\s*$' , arg ): self . choices = literal_eval ( arg . strip ()) if not hasattr ( self , 'type' ): # NOTE: Limit input that eval will parse if docstring . type_name in types : self . type = eval ( docstring . type_name ) # nosec elif self . default is not None : self . type = type ( self . default ) # if hasattr(self, 'type'): # self.metavar = (self.type.__name__) if docstring : self . help = docstring . description","title":"__init__()"},{"location":"development/parser/","text":"Argufy is an inspection based CLI parser. Parser Provide CLI parser for function. __init__ ( self , * args , ** kwargs ) special Initialize parser. str The name of the program str The string describing the program usage str Text to display before the argument help str Text to display after the argument help list A list of ArgumentParser objects whose arguments should also be included Object A class for customizing the help output char The set of characters that prefix optional arguments None The set of characters that prefix files from which additional arguments should be read None The global default value for arguments Object The strategy for resolving conflicting optionals str Add a -h/--help option to the parser bool Allows long options to be abbreviated if the abbreviation is unambiguous Source code in argufy/parser.py def __init__ ( self , * args : str , ** kwargs : str ) -> None : '''Initialize parser. Parameters ---------- prog: str The name of the program usage: str The string describing the program usage description: str Text to display before the argument help epilog: str Text to display after the argument help parents: list A list of ArgumentParser objects whose arguments should also be included formatter_class: Object A class for customizing the help output prefix_chars: char The set of characters that prefix optional arguments fromfile_prefix_chars: None The set of characters that prefix files from which additional arguments should be read argument_default: None The global default value for arguments conflict_handler: Object The strategy for resolving conflicting optionals add_help: str Add a -h/--help option to the parser allow_abbrev: bool Allows long options to be abbreviated if the abbreviation is unambiguous ''' # TODO: handle environment variables module = self . __get_parent_module () if module : docstring = parse ( module . __doc__ ) if not kwargs . get ( 'description' ): kwargs [ 'description' ] = docstring . short_description if 'prog' not in kwargs : kwargs [ 'prog' ] = module . __name__ . split ( '.' )[ 0 ] # if 'prefix' in kwargs: # self.prefix = kwargs.pop('prefix') # else: # self.prefix = kwargs['prog'].upper() # print(self.prefix) if 'formatter_class' not in kwargs : self . formatter_class = ArgufyHelpFormatter if 'log_level' in kwargs : log . setLevel ( getattr ( logging , kwargs . pop ( 'log_level' ) . upper ())) if 'log_handler' in kwargs : log_handler = kwargs . pop ( 'log_handler' ) log . addHandler ( logging . StreamHandler ( log_handler )) # type: ignore if 'version' in kwargs : self . prog_version = kwargs . pop ( 'version' ) self . command_type = kwargs . pop ( 'command_type' , None ) super () . __init__ ( ** kwargs ) # type: ignore # NOTE: cannot move to formatter self . _positionals . title = ArgufyHelpFormatter . font ( self . _positionals . title or 'arguments' ) self . _optionals . title = ArgufyHelpFormatter . font ( self . _optionals . title or 'flags' ) if hasattr ( self , 'prog_version' ): self . add_argument ( '--version' , action = 'version' , version = f \"%(prog)s { self . prog_version } \" , help = 'display package version' , ) add_arguments ( self , obj , parser = None ) Add arguments to parser/subparser. Source code in argufy/parser.py def add_arguments ( self , obj : Any , parser : Optional [ ArgumentParser ] = None ) -> 'Parser' : '''Add arguments to parser/subparser.''' if not parser : parser = self docstring = parse ( obj . __doc__ ) signature = inspect . signature ( obj ) for arg in signature . parameters : description = next ( ( d for d in docstring . params if d . arg_name == arg ), None , ) arguments = self . __get_args ( Argument ( signature . parameters [ arg ], description ) ) log . debug ( f \"arguments { arguments } \" ) name = arguments . pop ( 'name' ) parser . add_argument ( * name , ** arguments ) return self add_commands ( self , module , parser = None , exclude_prefixes = (), command_type = None ) Add commands. Source code in argufy/parser.py def add_commands ( self , module : ModuleType , parser : Optional [ ArgumentParser ] = None , exclude_prefixes : tuple = tuple (), command_type : Optional [ str ] = None , ) -> 'Parser' : '''Add commands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) # use self or an existing parser if not parser : parser = self # use exsiting subparser or create a new one if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name , parser_class = Parser ) # check if command exists command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) # set command name scheme if command_type is None : command_type = self . command_type excludes = Parser . _get_excludes ( exclude_prefixes ) for name , value in inspect . getmembers ( module ): # TODO: Possible singledispatch candidate if not name . startswith ( excludes ): # skip classes for now if inspect . isclass ( value ): continue # pragma: no cover # create commands from functions elif inspect . isfunction ( value ): # or inspect.ismethod(value): # TODO: Turn parameter-less function into switch if ( module . __name__ == value . __module__ and not name . startswith ( ', ' . join ( excludes )) ): if command : # apply command name scheme if command_type == 'chain' : cmd_name = module_name + '.' + name else : cmd_name = name msg = parse ( value . __doc__ ) . short_description cmd = command . add_parser ( cmd_name . replace ( '_' , '-' ), description = msg , formatter_class = ArgufyHelpFormatter , help = msg , ) cmd . set_defaults ( fn = value ) parser . formatter_class = ArgufyHelpFormatter log . debug ( f \"command { name } { value } { cmd } \" ) self . add_arguments ( value , cmd ) # create arguments from module varibles elif isinstance ( value , ( float , int , str , list , dict , tuple )): # TODO: Reconcile inspect parameters with dict parameters = inspect . Parameter ( name , _ParameterKind . POSITIONAL_OR_KEYWORD , # type: ignore default = getattr ( module , name ), annotation = inspect . _empty , # type: ignore ) description = next ( ( d for d in docstring . params if d . arg_name == name ), None , ) arguments = self . __get_args ( Argument ( parameters , description ) ) name = arguments . pop ( 'name' ) parser . add_argument ( * name , ** arguments ) return self add_subcommands ( self , module , parser = None , exclude_prefixes = ()) Add subcommands. Source code in argufy/parser.py def add_subcommands ( self , module : ModuleType , parser : Optional [ ArgumentParser ] = None , exclude_prefixes : tuple = tuple (), ) -> 'Parser' : '''Add subcommands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) # use self or an existing parser if not parser : parser = self # use exsiting subparser or create a new one if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name , parser_class = Parser ) # check if command exists command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) # create subcommand for command if command : msg = docstring . short_description subcommand = command . add_parser ( module_name . replace ( '_' , '-' ), description = msg , formatter_class = ArgufyHelpFormatter , help = msg , ) subcommand . set_defaults ( mod = module ) parser . formatter_class = ArgufyHelpFormatter # append subcommand to exsiting command or create a new one self . add_commands ( module = module , parser = subcommand , exclude_prefixes = Parser . _get_excludes ( exclude_prefixes ), ) return self dispatch ( self , args = [ '--line-by-line' ], ns = None ) Call command with arguments. Source code in argufy/parser.py def dispatch ( self , args : Sequence [ str ] = sys . argv [ 1 :], ns : Optional [ Namespace ] = None , ) -> Optional [ Callable [[ F ], F ]]: '''Call command with arguments.''' # TODO: support command chaining at same level # parse variables arguments , namespace = self . retrieve ( args , ns ) # call function with variables if 'fn' in namespace : fn = vars ( namespace ) . pop ( 'fn' ) namespace = self . __set_module_arguments ( fn , namespace ) return fn ( ** vars ( namespace )) return None retrieve ( self , args = [ '--line-by-line' ], ns = None ) Retrieve values from CLI. Source code in argufy/parser.py def retrieve ( self , args : Sequence [ str ] = sys . argv [ 1 :], ns : Optional [ Namespace ] = None , ) -> Tuple [ List [ str ], Namespace ]: '''Retrieve values from CLI.''' # TODO: handle invalid argument # show help when no arguments provided if args == []: args = [ '--help' ] # pragma: no cover main_ns , main_args = self . parse_known_args ( args , ns ) if main_args == [] and 'fn' in vars ( main_ns ): return main_args , main_ns else : # default to help message for subcommand if 'mod' in vars ( main_ns ): a = [] a . append ( vars ( main_ns )[ 'mod' ] . __name__ . split ( '.' )[ - 1 ]) a . append ( '--help' ) self . parse_args ( a ) return main_args , main_ns","title":"Parser"},{"location":"development/parser/#argufy.parser","text":"Argufy is an inspection based CLI parser.","title":"argufy.parser"},{"location":"development/parser/#argufy.parser.Parser","text":"Provide CLI parser for function.","title":"Parser"},{"location":"development/parser/#argufy.parser.Parser.__init__","text":"Initialize parser. str The name of the program str The string describing the program usage str Text to display before the argument help str Text to display after the argument help list A list of ArgumentParser objects whose arguments should also be included Object A class for customizing the help output char The set of characters that prefix optional arguments None The set of characters that prefix files from which additional arguments should be read None The global default value for arguments Object The strategy for resolving conflicting optionals str Add a -h/--help option to the parser bool Allows long options to be abbreviated if the abbreviation is unambiguous Source code in argufy/parser.py def __init__ ( self , * args : str , ** kwargs : str ) -> None : '''Initialize parser. Parameters ---------- prog: str The name of the program usage: str The string describing the program usage description: str Text to display before the argument help epilog: str Text to display after the argument help parents: list A list of ArgumentParser objects whose arguments should also be included formatter_class: Object A class for customizing the help output prefix_chars: char The set of characters that prefix optional arguments fromfile_prefix_chars: None The set of characters that prefix files from which additional arguments should be read argument_default: None The global default value for arguments conflict_handler: Object The strategy for resolving conflicting optionals add_help: str Add a -h/--help option to the parser allow_abbrev: bool Allows long options to be abbreviated if the abbreviation is unambiguous ''' # TODO: handle environment variables module = self . __get_parent_module () if module : docstring = parse ( module . __doc__ ) if not kwargs . get ( 'description' ): kwargs [ 'description' ] = docstring . short_description if 'prog' not in kwargs : kwargs [ 'prog' ] = module . __name__ . split ( '.' )[ 0 ] # if 'prefix' in kwargs: # self.prefix = kwargs.pop('prefix') # else: # self.prefix = kwargs['prog'].upper() # print(self.prefix) if 'formatter_class' not in kwargs : self . formatter_class = ArgufyHelpFormatter if 'log_level' in kwargs : log . setLevel ( getattr ( logging , kwargs . pop ( 'log_level' ) . upper ())) if 'log_handler' in kwargs : log_handler = kwargs . pop ( 'log_handler' ) log . addHandler ( logging . StreamHandler ( log_handler )) # type: ignore if 'version' in kwargs : self . prog_version = kwargs . pop ( 'version' ) self . command_type = kwargs . pop ( 'command_type' , None ) super () . __init__ ( ** kwargs ) # type: ignore # NOTE: cannot move to formatter self . _positionals . title = ArgufyHelpFormatter . font ( self . _positionals . title or 'arguments' ) self . _optionals . title = ArgufyHelpFormatter . font ( self . _optionals . title or 'flags' ) if hasattr ( self , 'prog_version' ): self . add_argument ( '--version' , action = 'version' , version = f \"%(prog)s { self . prog_version } \" , help = 'display package version' , )","title":"__init__()"},{"location":"development/parser/#argufy.parser.Parser.add_arguments","text":"Add arguments to parser/subparser. Source code in argufy/parser.py def add_arguments ( self , obj : Any , parser : Optional [ ArgumentParser ] = None ) -> 'Parser' : '''Add arguments to parser/subparser.''' if not parser : parser = self docstring = parse ( obj . __doc__ ) signature = inspect . signature ( obj ) for arg in signature . parameters : description = next ( ( d for d in docstring . params if d . arg_name == arg ), None , ) arguments = self . __get_args ( Argument ( signature . parameters [ arg ], description ) ) log . debug ( f \"arguments { arguments } \" ) name = arguments . pop ( 'name' ) parser . add_argument ( * name , ** arguments ) return self","title":"add_arguments()"},{"location":"development/parser/#argufy.parser.Parser.add_commands","text":"Add commands. Source code in argufy/parser.py def add_commands ( self , module : ModuleType , parser : Optional [ ArgumentParser ] = None , exclude_prefixes : tuple = tuple (), command_type : Optional [ str ] = None , ) -> 'Parser' : '''Add commands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) # use self or an existing parser if not parser : parser = self # use exsiting subparser or create a new one if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name , parser_class = Parser ) # check if command exists command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) # set command name scheme if command_type is None : command_type = self . command_type excludes = Parser . _get_excludes ( exclude_prefixes ) for name , value in inspect . getmembers ( module ): # TODO: Possible singledispatch candidate if not name . startswith ( excludes ): # skip classes for now if inspect . isclass ( value ): continue # pragma: no cover # create commands from functions elif inspect . isfunction ( value ): # or inspect.ismethod(value): # TODO: Turn parameter-less function into switch if ( module . __name__ == value . __module__ and not name . startswith ( ', ' . join ( excludes )) ): if command : # apply command name scheme if command_type == 'chain' : cmd_name = module_name + '.' + name else : cmd_name = name msg = parse ( value . __doc__ ) . short_description cmd = command . add_parser ( cmd_name . replace ( '_' , '-' ), description = msg , formatter_class = ArgufyHelpFormatter , help = msg , ) cmd . set_defaults ( fn = value ) parser . formatter_class = ArgufyHelpFormatter log . debug ( f \"command { name } { value } { cmd } \" ) self . add_arguments ( value , cmd ) # create arguments from module varibles elif isinstance ( value , ( float , int , str , list , dict , tuple )): # TODO: Reconcile inspect parameters with dict parameters = inspect . Parameter ( name , _ParameterKind . POSITIONAL_OR_KEYWORD , # type: ignore default = getattr ( module , name ), annotation = inspect . _empty , # type: ignore ) description = next ( ( d for d in docstring . params if d . arg_name == name ), None , ) arguments = self . __get_args ( Argument ( parameters , description ) ) name = arguments . pop ( 'name' ) parser . add_argument ( * name , ** arguments ) return self","title":"add_commands()"},{"location":"development/parser/#argufy.parser.Parser.add_subcommands","text":"Add subcommands. Source code in argufy/parser.py def add_subcommands ( self , module : ModuleType , parser : Optional [ ArgumentParser ] = None , exclude_prefixes : tuple = tuple (), ) -> 'Parser' : '''Add subcommands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) # use self or an existing parser if not parser : parser = self # use exsiting subparser or create a new one if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name , parser_class = Parser ) # check if command exists command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) # create subcommand for command if command : msg = docstring . short_description subcommand = command . add_parser ( module_name . replace ( '_' , '-' ), description = msg , formatter_class = ArgufyHelpFormatter , help = msg , ) subcommand . set_defaults ( mod = module ) parser . formatter_class = ArgufyHelpFormatter # append subcommand to exsiting command or create a new one self . add_commands ( module = module , parser = subcommand , exclude_prefixes = Parser . _get_excludes ( exclude_prefixes ), ) return self","title":"add_subcommands()"},{"location":"development/parser/#argufy.parser.Parser.dispatch","text":"Call command with arguments. Source code in argufy/parser.py def dispatch ( self , args : Sequence [ str ] = sys . argv [ 1 :], ns : Optional [ Namespace ] = None , ) -> Optional [ Callable [[ F ], F ]]: '''Call command with arguments.''' # TODO: support command chaining at same level # parse variables arguments , namespace = self . retrieve ( args , ns ) # call function with variables if 'fn' in namespace : fn = vars ( namespace ) . pop ( 'fn' ) namespace = self . __set_module_arguments ( fn , namespace ) return fn ( ** vars ( namespace )) return None","title":"dispatch()"},{"location":"development/parser/#argufy.parser.Parser.retrieve","text":"Retrieve values from CLI. Source code in argufy/parser.py def retrieve ( self , args : Sequence [ str ] = sys . argv [ 1 :], ns : Optional [ Namespace ] = None , ) -> Tuple [ List [ str ], Namespace ]: '''Retrieve values from CLI.''' # TODO: handle invalid argument # show help when no arguments provided if args == []: args = [ '--help' ] # pragma: no cover main_ns , main_args = self . parse_known_args ( args , ns ) if main_args == [] and 'fn' in vars ( main_ns ): return main_args , main_ns else : # default to help message for subcommand if 'mod' in vars ( main_ns ): a = [] a . append ( vars ( main_ns )[ 'mod' ] . __name__ . split ( '.' )[ - 1 ]) a . append ( '--help' ) self . parse_args ( a ) return main_args , main_ns","title":"retrieve()"}]}