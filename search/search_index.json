{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Argufy Inspection-based command line interface (CLI) written in Python. Overview Argufy is built around Argparse to create CLI's. First, inspection is used to determine each command and arguments to be created. Next, docstrings are parsed to fill in any additional settings. Motivation This parser was created because there wasn't a parser that built on what I believed are some real strenths of Python. Inspection is a really powerfull tool and I wanted a CLI that would be updated with minimal effort. Argufy does this by building CLI's from the functions directly. It then parses docstrings to fill in any additional content to create a parser. In short, the more code-complete your application is the more complete the CLI. Alternatives There are multiple alternatives such as Click and Docpopt. These are great options but each have their own trade-offs. Argparse Argparse is a great parser with many built-in features. But, it is an additional layer of complexity that needs to be managed when developing with it. Click Click is a great alternative and is widely used. It is also part of the Pallets Projects suite of tools. Click is a decorator based CLI parser. Decorators are easy and convenient but prevent inspection from being used without a performance and capability hit. It also requires that your code be wrapped with the decorators. This is less usefull when needing the tools to function also as a library. Docopt Docopt is another great option for CLI parsers and is similar in scope to Argufy. It works by parsing docstrings directly in the main module of an applications. A CLI is created by adding the syntax directly into docstrings. Updates to an application still requires that the CLI also be updated independently.","title":"Overview"},{"location":"#welcome-to-argufy","text":"Inspection-based command line interface (CLI) written in Python.","title":"Welcome to Argufy"},{"location":"#overview","text":"Argufy is built around Argparse to create CLI's. First, inspection is used to determine each command and arguments to be created. Next, docstrings are parsed to fill in any additional settings.","title":"Overview"},{"location":"#motivation","text":"This parser was created because there wasn't a parser that built on what I believed are some real strenths of Python. Inspection is a really powerfull tool and I wanted a CLI that would be updated with minimal effort. Argufy does this by building CLI's from the functions directly. It then parses docstrings to fill in any additional content to create a parser. In short, the more code-complete your application is the more complete the CLI.","title":"Motivation"},{"location":"#alternatives","text":"There are multiple alternatives such as Click and Docpopt. These are great options but each have their own trade-offs. Argparse Argparse is a great parser with many built-in features. But, it is an additional layer of complexity that needs to be managed when developing with it. Click Click is a great alternative and is widely used. It is also part of the Pallets Projects suite of tools. Click is a decorator based CLI parser. Decorators are easy and convenient but prevent inspection from being used without a performance and capability hit. It also requires that your code be wrapped with the decorators. This is less usefull when needing the tools to function also as a library. Docopt Docopt is another great option for CLI parsers and is similar in scope to Argufy. It works by parsing docstrings directly in the main module of an applications. A CLI is created by adding the syntax directly into docstrings. Updates to an application still requires that the CLI also be updated independently.","title":"Alternatives"},{"location":"commands/","text":"Commands Overview The commands module takes a module as an argument and inspects it for functions. These functions are then used to populate CLI commands. It is different from the subcommands module in that the module isn't used to as a command itself. This command is usefull either for all-in-modules or a module that is holding functions that combine an applications parts into a CLI. Convert Module to CLI To create a CLI start with a module of functions to convert. def example_bool(bool_check = False): print(bool_check) def example_choice(choice_check = 'A'): print(choice_check) Creating a parser Next create a parser to from argufy import Parser from . import cli def main(): '''Do main function for a cli module.''' parser = Parser() parser.add_commands(cli) parser.dispatch() if __name__ == '__main__': main() Pack loading order Using __main__ vs __init__ for CLI instances.","title":"Commands"},{"location":"commands/#commands","text":"","title":"Commands"},{"location":"commands/#overview","text":"The commands module takes a module as an argument and inspects it for functions. These functions are then used to populate CLI commands. It is different from the subcommands module in that the module isn't used to as a command itself. This command is usefull either for all-in-modules or a module that is holding functions that combine an applications parts into a CLI.","title":"Overview"},{"location":"commands/#convert-module-to-cli","text":"To create a CLI start with a module of functions to convert. def example_bool(bool_check = False): print(bool_check) def example_choice(choice_check = 'A'): print(choice_check)","title":"Convert Module to CLI"},{"location":"commands/#creating-a-parser","text":"Next create a parser to from argufy import Parser from . import cli def main(): '''Do main function for a cli module.''' parser = Parser() parser.add_commands(cli) parser.dispatch() if __name__ == '__main__': main()","title":"Creating a parser"},{"location":"commands/#pack-loading-order","text":"Using __main__ vs __init__ for CLI instances.","title":"Pack loading order"},{"location":"docstrings/","text":"","title":"Docstrings"},{"location":"getting-started/","text":"Getting Started The document is intended to help quickly get started using Argufy. Installation pip install argufy Convert Module to CLI To create a CLI start with a module of functions to convert. def example_bool(bool_check = False): print(bool_check) Creating a parser Next create a parser to from argufy import Parser from . import cli def main(): parser = Parser() parser.add_commands(cli) parser.dispatch() if __name__ == '__main__': main() Running Commands python -m check.py Example help message usage: argufy [-h] {example-bool,example-choice} ... Argufier is an inspection based CLI parser. positional arguments: {example-bool} example-bool optional arguments: -h, --help show this help message and exit Example command with output $ python -m check.py example-bool --bool-check=True True","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"The document is intended to help quickly get started using Argufy.","title":"Getting Started"},{"location":"getting-started/#installation","text":"pip install argufy","title":"Installation"},{"location":"getting-started/#convert-module-to-cli","text":"To create a CLI start with a module of functions to convert. def example_bool(bool_check = False): print(bool_check)","title":"Convert Module to CLI"},{"location":"getting-started/#creating-a-parser","text":"Next create a parser to from argufy import Parser from . import cli def main(): parser = Parser() parser.add_commands(cli) parser.dispatch() if __name__ == '__main__': main()","title":"Creating a parser"},{"location":"getting-started/#running-commands","text":"python -m check.py","title":"Running Commands"},{"location":"getting-started/#example-help-message","text":"usage: argufy [-h] {example-bool,example-choice} ... Argufier is an inspection based CLI parser. positional arguments: {example-bool} example-bool optional arguments: -h, --help show this help message and exit","title":"Example help message"},{"location":"getting-started/#example-command-with-output","text":"$ python -m check.py example-bool --bool-check=True True","title":"Example command with output"},{"location":"roadmap/","text":"Roadmap The intent is to be able to allow parsers to be built from any object a developer wishes. Note Currently, only methods inspection is fully supported. Features Generate commands from functions within modules Dispatch commands arguments to functions Create arguments from function Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from modules Create subcommand arguments from module arguments Set module arguments Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from objects Dispatch commands arguments to functions Create subcommand arguments from instance arguments Set instance arguments Type Hints Defaults Help Types Docstrings Defaults Help Types","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"The intent is to be able to allow parsers to be built from any object a developer wishes. Note Currently, only methods inspection is fully supported.","title":"Roadmap"},{"location":"roadmap/#features","text":"Generate commands from functions within modules Dispatch commands arguments to functions Create arguments from function Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from modules Create subcommand arguments from module arguments Set module arguments Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from objects Dispatch commands arguments to functions Create subcommand arguments from instance arguments Set instance arguments Type Hints Defaults Help Types Docstrings Defaults Help Types","title":"Features"},{"location":"subcommands/","text":"","title":"Subcommands"},{"location":"type-hints/","text":"","title":"Type hints"},{"location":"development/argument/","text":"Arguments for inspection based CLI parser. Argument Represent argparse arguments. action: str property writable Get argparse argument action. choices: str property writable Get argparse argument choices. const: str property writable Get argparse argument const. default: Any property writable Get argparse argument default. dest: str property writable Get argparse command/argument dest. help: str property writable Get argparse command/argument help message. metavar: str property writable Get argparse argument metavar. name: List [ str ] property writable Get argparse command/argument name. nargs: str property writable Get argparse argument nargs. required: bool property writable Get argparse required argument. type: Any property writable Get argparse argument type. __init__ ( self , parameters , docstring ) special Initialize argparse argument. Source code in argufy/argument.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , parameters : Type [ inspect . Parameter ], docstring : Type [ DocstringParam ], ) -> None : '''Initialize argparse argument.''' self . attributes : Dict [ Any , Any ] = {} self . default = parameters . default self . name = parameters . name . replace ( '_' , '-' ) # type: ignore if parameters . annotation != inspect . _empty : # type: ignore annotation = parameters . annotation elif docstring and docstring . type_name : # TODO: There has to be a cleaner way annotation = eval ( docstring . type_name ) # nosec else : annotation = None if type ( annotation ) == bool : # Note: these store type internally if self . attributes . get ( 'default' ): self . action = 'store_false' else : self . action = 'store_true' elif type ( annotation ) == int : self . type = annotation self . action = 'append' elif type ( annotation ) == list : self . type = annotation self . nargs = '+' elif type ( annotation ) == tuple : self . type = annotation [ 0 ] if type ( annotation [ 1 ]) == set : self . choices = annotation [ 1 ] else : self . type = annotation self . metavar = ( parameters . name ) . upper () if docstring : self . help = docstring . description","title":"Argument"},{"location":"development/argument/#argufy.argument","text":"Arguments for inspection based CLI parser.","title":"argufy.argument"},{"location":"development/argument/#argufy.argument.Argument","text":"Represent argparse arguments.","title":"Argument"},{"location":"development/argument/#argufy.argument.Argument.action","text":"Get argparse argument action.","title":"action"},{"location":"development/argument/#argufy.argument.Argument.choices","text":"Get argparse argument choices.","title":"choices"},{"location":"development/argument/#argufy.argument.Argument.const","text":"Get argparse argument const.","title":"const"},{"location":"development/argument/#argufy.argument.Argument.default","text":"Get argparse argument default.","title":"default"},{"location":"development/argument/#argufy.argument.Argument.dest","text":"Get argparse command/argument dest.","title":"dest"},{"location":"development/argument/#argufy.argument.Argument.help","text":"Get argparse command/argument help message.","title":"help"},{"location":"development/argument/#argufy.argument.Argument.metavar","text":"Get argparse argument metavar.","title":"metavar"},{"location":"development/argument/#argufy.argument.Argument.name","text":"Get argparse command/argument name.","title":"name"},{"location":"development/argument/#argufy.argument.Argument.nargs","text":"Get argparse argument nargs.","title":"nargs"},{"location":"development/argument/#argufy.argument.Argument.required","text":"Get argparse required argument.","title":"required"},{"location":"development/argument/#argufy.argument.Argument.type","text":"Get argparse argument type.","title":"type"},{"location":"development/argument/#argufy.argument.Argument.__init__","text":"Initialize argparse argument. Source code in argufy/argument.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , parameters : Type [ inspect . Parameter ], docstring : Type [ DocstringParam ], ) -> None : '''Initialize argparse argument.''' self . attributes : Dict [ Any , Any ] = {} self . default = parameters . default self . name = parameters . name . replace ( '_' , '-' ) # type: ignore if parameters . annotation != inspect . _empty : # type: ignore annotation = parameters . annotation elif docstring and docstring . type_name : # TODO: There has to be a cleaner way annotation = eval ( docstring . type_name ) # nosec else : annotation = None if type ( annotation ) == bool : # Note: these store type internally if self . attributes . get ( 'default' ): self . action = 'store_false' else : self . action = 'store_true' elif type ( annotation ) == int : self . type = annotation self . action = 'append' elif type ( annotation ) == list : self . type = annotation self . nargs = '+' elif type ( annotation ) == tuple : self . type = annotation [ 0 ] if type ( annotation [ 1 ]) == set : self . choices = annotation [ 1 ] else : self . type = annotation self . metavar = ( parameters . name ) . upper () if docstring : self . help = docstring . description","title":"__init__()"},{"location":"development/parser/","text":"Argufier is an inspection based CLI parser. Parser Provide CLI parser for function. __init__ ( self , * args , ** kwargs ) special Initialize parser. str The name of the program str The string describing the program usage str Text to display before the argument help str Text to display after the argument help list A list of ArgumentParser objects whose arguments should also be included Object A class for customizing the help output char The set of characters that prefix optional arguments None The set of characters that prefix files from which additional arguments should be read None The global default value for arguments Object The strategy for resolving conflicting optionals str Add a -h/--help option to the parser bool Allows long options to be abbreviated if the abbreviation is unambiguous Source code in argufy/parser.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , * args : str , ** kwargs : str ) -> None : '''Initialize parser. Parameters ---------- prog: str The name of the program usage: str The string describing the program usage description: str Text to display before the argument help epilog: str Text to display after the argument help parents: list A list of ArgumentParser objects whose arguments should also be included formatter_class: Object A class for customizing the help output prefix_chars: char The set of characters that prefix optional arguments fromfile_prefix_chars: None The set of characters that prefix files from which additional arguments should be read argument_default: None The global default value for arguments conflict_handler: Object The strategy for resolving conflicting optionals add_help: str Add a -h/--help option to the parser allow_abbrev: bool Allows long options to be abbreviated if the abbreviation is unambiguous ''' module = self . __get_parent_module () if module : docstring = parse ( module . __doc__ ) if not kwargs . get ( 'description' ): kwargs [ 'description' ] = docstring . short_description if 'prog' not in kwargs : kwargs [ 'prog' ] = module . __name__ . split ( '.' )[ 0 ] if 'version' in kwargs : self . version = kwargs . pop ( 'version' ) super () . __init__ ( ** kwargs ) # type: ignore add_arguments ( self , obj , parser = None ) Add arguments to parser/subparser. Source code in argufy/parser.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_arguments ( self , obj : Any , parser : Optional [ Type [ ArgumentParser ]] = None ) -> Type [ ArgumentParser ]: '''Add arguments to parser/subparser.''' if not parser : parser = self # type: ignore docstring = parse ( obj . __doc__ ) signature = inspect . signature ( obj ) for arg in signature . parameters : description = next ( ( d for d in docstring . params if d . arg_name == arg ), None ) argument = Argument ( signature . parameters [ arg ], description # type: ignore ) # print('sig:', signature.parameters[arg]) name = argument . attributes . pop ( 'name' ) parser . add_argument ( * name , ** argument . attributes ) return self add_commands ( self , module , exclude_prefix = [ '@' , '_' ], parser = None ) Add commands. Source code in argufy/parser.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def add_commands ( self , module : ModuleType , exclude_prefix : list = [ '@' , '_' ], parser : Optional [ Type [ ArgumentParser ]] = None , ) -> Type [ ArgumentParser ]: '''Add commands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) parameters = {} if not parser : parser = self # type: ignore if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name ) command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) # self._load_module(module, command, exclude_prefix) for name , value in inspect . getmembers ( module ): # TODO: Possible singledispatch candidate if not name . startswith ( self . __exclude_prefixes__ ): if inspect . isclass ( value ): continue elif inspect . isfunction ( value ) or inspect . ismethod ( value ): if ( module . __name__ == value . __module__ and not name . startswith ( ( ', ' . join ( self . __exclude_prefixes__ )) ) ): cmd = command . add_parser ( name . replace ( '_' , '-' ), help = parse ( value . __doc__ ) . short_description , ) cmd . set_defaults ( fn = value ) self . add_arguments ( value , cmd ) elif isinstance ( value , ( float , int , str , list , dict , tuple )): # TODO: Reconcile inspect parameters with dict parameters = inspect . Parameter ( name , inspect . _ParameterKind . POSITIONAL_OR_KEYWORD , default = getattr ( module , name ), annotation = inspect . _empty , # TODO: Inspect type ) description = next ( ( d for d in docstring . params if d . arg_name == name ), None , ) # print(name, parameters, description) argument = Argument ( parameters , description ) name = argument . attributes . pop ( 'name' ) parser . add_argument ( * name , ** argument . attributes ) return self add_subcommands ( self , module , exclude_prefix = [ '@' , '_' ], parser = None ) Add subcommands. Source code in argufy/parser.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def add_subcommands ( self , module : ModuleType , exclude_prefix : list = [ '@' , '_' ], parser : Optional [ Type [ ArgumentParser ]] = None , ) -> Type [ ArgumentParser ]: '''Add subcommands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) if not parser : parser = self # type: ignore if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name ) command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) subcommand = command . add_parser ( module_name . replace ( '_' , '-' ), help = docstring . short_description , ) subcommand . set_defaults ( mod = module ) self . add_commands ( module , exclude_prefix , subcommand ) return self dispatch ( self , args = None , ns = None ) Call command with arguments. Source code in argufy/parser.py 227 228 229 230 231 232 233 234 235 236 237 def dispatch ( self , args : Sequence [ str ] = None , ns : Optional [ str ] = None , ) -> Callable [[ F ], F ]: '''Call command with arguments.''' if sys . argv [ 1 :] == [] and args is None : args = [ '--help' ] arguments , namespace = self . retrieve ( args , ns ) if 'fn' in namespace : fn = vars ( namespace ) . pop ( 'fn' ) namespace = self . __set_module_arguments ( fn , namespace ) return fn ( ** vars ( namespace )) retrieve ( self , args = None , ns = None ) Retrieve values from CLI. Source code in argufy/parser.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def retrieve ( self , args : Sequence [ str ] = None , ns : Optional [ str ] = None , ) -> None : '''Retrieve values from CLI.''' main_ns , main_args = self . parse_known_args ( args , ns ) if main_args == [] and 'fn' in vars ( main_ns ): return main_args , main_ns else : if 'mod' in vars ( main_ns ): a = [] a . append ( vars ( main_ns )[ 'mod' ] . __name__ . split ( '.' )[ - 1 ]) a . append ( '--help' ) self . parse_args ( a ) return None","title":"Parser"},{"location":"development/parser/#argufy.parser","text":"Argufier is an inspection based CLI parser.","title":"argufy.parser"},{"location":"development/parser/#argufy.parser.Parser","text":"Provide CLI parser for function.","title":"Parser"},{"location":"development/parser/#argufy.parser.Parser.__init__","text":"Initialize parser. str The name of the program str The string describing the program usage str Text to display before the argument help str Text to display after the argument help list A list of ArgumentParser objects whose arguments should also be included Object A class for customizing the help output char The set of characters that prefix optional arguments None The set of characters that prefix files from which additional arguments should be read None The global default value for arguments Object The strategy for resolving conflicting optionals str Add a -h/--help option to the parser bool Allows long options to be abbreviated if the abbreviation is unambiguous Source code in argufy/parser.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , * args : str , ** kwargs : str ) -> None : '''Initialize parser. Parameters ---------- prog: str The name of the program usage: str The string describing the program usage description: str Text to display before the argument help epilog: str Text to display after the argument help parents: list A list of ArgumentParser objects whose arguments should also be included formatter_class: Object A class for customizing the help output prefix_chars: char The set of characters that prefix optional arguments fromfile_prefix_chars: None The set of characters that prefix files from which additional arguments should be read argument_default: None The global default value for arguments conflict_handler: Object The strategy for resolving conflicting optionals add_help: str Add a -h/--help option to the parser allow_abbrev: bool Allows long options to be abbreviated if the abbreviation is unambiguous ''' module = self . __get_parent_module () if module : docstring = parse ( module . __doc__ ) if not kwargs . get ( 'description' ): kwargs [ 'description' ] = docstring . short_description if 'prog' not in kwargs : kwargs [ 'prog' ] = module . __name__ . split ( '.' )[ 0 ] if 'version' in kwargs : self . version = kwargs . pop ( 'version' ) super () . __init__ ( ** kwargs ) # type: ignore","title":"__init__()"},{"location":"development/parser/#argufy.parser.Parser.add_arguments","text":"Add arguments to parser/subparser. Source code in argufy/parser.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_arguments ( self , obj : Any , parser : Optional [ Type [ ArgumentParser ]] = None ) -> Type [ ArgumentParser ]: '''Add arguments to parser/subparser.''' if not parser : parser = self # type: ignore docstring = parse ( obj . __doc__ ) signature = inspect . signature ( obj ) for arg in signature . parameters : description = next ( ( d for d in docstring . params if d . arg_name == arg ), None ) argument = Argument ( signature . parameters [ arg ], description # type: ignore ) # print('sig:', signature.parameters[arg]) name = argument . attributes . pop ( 'name' ) parser . add_argument ( * name , ** argument . attributes ) return self","title":"add_arguments()"},{"location":"development/parser/#argufy.parser.Parser.add_commands","text":"Add commands. Source code in argufy/parser.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def add_commands ( self , module : ModuleType , exclude_prefix : list = [ '@' , '_' ], parser : Optional [ Type [ ArgumentParser ]] = None , ) -> Type [ ArgumentParser ]: '''Add commands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) parameters = {} if not parser : parser = self # type: ignore if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name ) command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) # self._load_module(module, command, exclude_prefix) for name , value in inspect . getmembers ( module ): # TODO: Possible singledispatch candidate if not name . startswith ( self . __exclude_prefixes__ ): if inspect . isclass ( value ): continue elif inspect . isfunction ( value ) or inspect . ismethod ( value ): if ( module . __name__ == value . __module__ and not name . startswith ( ( ', ' . join ( self . __exclude_prefixes__ )) ) ): cmd = command . add_parser ( name . replace ( '_' , '-' ), help = parse ( value . __doc__ ) . short_description , ) cmd . set_defaults ( fn = value ) self . add_arguments ( value , cmd ) elif isinstance ( value , ( float , int , str , list , dict , tuple )): # TODO: Reconcile inspect parameters with dict parameters = inspect . Parameter ( name , inspect . _ParameterKind . POSITIONAL_OR_KEYWORD , default = getattr ( module , name ), annotation = inspect . _empty , # TODO: Inspect type ) description = next ( ( d for d in docstring . params if d . arg_name == name ), None , ) # print(name, parameters, description) argument = Argument ( parameters , description ) name = argument . attributes . pop ( 'name' ) parser . add_argument ( * name , ** argument . attributes ) return self","title":"add_commands()"},{"location":"development/parser/#argufy.parser.Parser.add_subcommands","text":"Add subcommands. Source code in argufy/parser.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def add_subcommands ( self , module : ModuleType , exclude_prefix : list = [ '@' , '_' ], parser : Optional [ Type [ ArgumentParser ]] = None , ) -> Type [ ArgumentParser ]: '''Add subcommands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) if not parser : parser = self # type: ignore if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name ) command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) subcommand = command . add_parser ( module_name . replace ( '_' , '-' ), help = docstring . short_description , ) subcommand . set_defaults ( mod = module ) self . add_commands ( module , exclude_prefix , subcommand ) return self","title":"add_subcommands()"},{"location":"development/parser/#argufy.parser.Parser.dispatch","text":"Call command with arguments. Source code in argufy/parser.py 227 228 229 230 231 232 233 234 235 236 237 def dispatch ( self , args : Sequence [ str ] = None , ns : Optional [ str ] = None , ) -> Callable [[ F ], F ]: '''Call command with arguments.''' if sys . argv [ 1 :] == [] and args is None : args = [ '--help' ] arguments , namespace = self . retrieve ( args , ns ) if 'fn' in namespace : fn = vars ( namespace ) . pop ( 'fn' ) namespace = self . __set_module_arguments ( fn , namespace ) return fn ( ** vars ( namespace ))","title":"dispatch()"},{"location":"development/parser/#argufy.parser.Parser.retrieve","text":"Retrieve values from CLI. Source code in argufy/parser.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def retrieve ( self , args : Sequence [ str ] = None , ns : Optional [ str ] = None , ) -> None : '''Retrieve values from CLI.''' main_ns , main_args = self . parse_known_args ( args , ns ) if main_args == [] and 'fn' in vars ( main_ns ): return main_args , main_ns else : if 'mod' in vars ( main_ns ): a = [] a . append ( vars ( main_ns )[ 'mod' ] . __name__ . split ( '.' )[ - 1 ]) a . append ( '--help' ) self . parse_args ( a ) return None","title":"retrieve()"}]}