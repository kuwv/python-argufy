{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Argufy Inspection-based command line interface (CLI) written in Python. Overview Argufy is built around Argparse to create CLI's. First, inspection is used to determine each command and arguments to be created. Next, docstrings are parsed to fill in any additional settings. Motivation This parser was created because there wasn't a parser that built on what I believed are some real strenths of Python. Inspection is a really powerfull tool and I wanted a CLI that would be updated with minimal effort. Argufy does this by building CLI's from the functions directly. It then parses docstrings to fill in any additional content to create a parser. In short, the more code-complete your application is the more complete the CLI. Alternatives There are multiple alternatives such as Click and Docpopt. These are great options but each have their own trade-offs. Argparse Argparse is a great parser with many built-in features. But, it is an additional layer of complexity that needs to be managed when developing with it. Click Click is a great alternative and is widely used. It is also part of the Pallets Projects suite of tools. Click is a decorator based CLI parser. Decorators are easy and convenient but prevent inspection from being used without a performance and capability hit. It also requires that your code be wrapped with the decorators. This is less usefull when needing the tools to function also as a library. Dockopt Docopt is another great option for CLI parsers and is similar in scope to Argufy. It works by parsing docstrings directly in the main module of an applications. A CLI is created by adding the syntax directly into docstrings. Updates to an application still requires that the CLI also be updated independently.","title":"Overview"},{"location":"#welcome-to-argufy","text":"Inspection-based command line interface (CLI) written in Python.","title":"Welcome to Argufy"},{"location":"#overview","text":"Argufy is built around Argparse to create CLI's. First, inspection is used to determine each command and arguments to be created. Next, docstrings are parsed to fill in any additional settings.","title":"Overview"},{"location":"#motivation","text":"This parser was created because there wasn't a parser that built on what I believed are some real strenths of Python. Inspection is a really powerfull tool and I wanted a CLI that would be updated with minimal effort. Argufy does this by building CLI's from the functions directly. It then parses docstrings to fill in any additional content to create a parser. In short, the more code-complete your application is the more complete the CLI.","title":"Motivation"},{"location":"#alternatives","text":"There are multiple alternatives such as Click and Docpopt. These are great options but each have their own trade-offs. Argparse Argparse is a great parser with many built-in features. But, it is an additional layer of complexity that needs to be managed when developing with it. Click Click is a great alternative and is widely used. It is also part of the Pallets Projects suite of tools. Click is a decorator based CLI parser. Decorators are easy and convenient but prevent inspection from being used without a performance and capability hit. It also requires that your code be wrapped with the decorators. This is less usefull when needing the tools to function also as a library. Dockopt Docopt is another great option for CLI parsers and is similar in scope to Argufy. It works by parsing docstrings directly in the main module of an applications. A CLI is created by adding the syntax directly into docstrings. Updates to an application still requires that the CLI also be updated independently.","title":"Alternatives"},{"location":"commands/","text":"","title":"Commands"},{"location":"docstrings/","text":"","title":"Docstrings"},{"location":"roadmap/","text":"Roadmap The intent is to be able to allow parsers to be built from any object a developer wishes. Note Currently, only methods inspection is fully supported. Features Generate commands from functions within modules Dispatch commands arguments to functions Create arguments from function Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from modules Create subcommand arguments from module arguments Set module arguments Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from objects Dispatch commands arguments to functions Create subcommand arguments from instance arguments Set instance arguments Type Hints Defaults Help Types Docstrings Defaults Help Types","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"The intent is to be able to allow parsers to be built from any object a developer wishes. Note Currently, only methods inspection is fully supported.","title":"Roadmap"},{"location":"roadmap/#features","text":"Generate commands from functions within modules Dispatch commands arguments to functions Create arguments from function Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from modules Create subcommand arguments from module arguments Set module arguments Type Hints Defaults Help (N/A) Types Docstrings Defaults Help Types Generate subcommands / arguments from objects Dispatch commands arguments to functions Create subcommand arguments from instance arguments Set instance arguments Type Hints Defaults Help Types Docstrings Defaults Help Types","title":"Features"},{"location":"subcommands/","text":"","title":"Subcommands"},{"location":"type-hints/","text":"","title":"Type hints"},{"location":"development/argument/","text":"Arguments for inspection based CLI parser. Argument Represent argparse arguments. __init__ ( self , parameters , docstring ) special Initialize argparse argument. Source code in argufy/argument.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , parameters : Type [ inspect . Parameter ], docstring : Type [ DocstringParam ], ) -> None : '''Initialize argparse argument.''' self . attributes : Dict [ Any , Any ] = {} self . __docstring = docstring # Define attribute defaults self . nargs_type = '+' default = parameters . default name = parameters . name . replace ( '_' , '-' ) if default == inspect . _empty : # type: ignore self . attributes [ 'name' ] = [ name ] else : self . attributes [ 'name' ] = [ '--' + name ] self . attributes [ 'default' ] = default self . set_attributes ( self . get_annotations ( parameters . annotation )) if self . attributes [ 'type' ] != bool : self . attributes [ 'metavar' ] = ( parameters . name ) . upper () if self . __docstring : self . attributes [ 'help' ] = self . __docstring . description get_annotations ( self , annotation ) Get parameter types for method/function. Source code in argufy/argument.py 45 46 47 48 49 50 51 52 53 54 def get_annotations ( self , annotation : Any ) -> Any : '''Get parameter types for method/function.''' if annotation != inspect . _empty : # type: ignore return annotation elif self . __docstring and self . __docstring . type_name : # TODO: There has to be a cleaner way annotation = eval ( self . __docstring . type_name ) # nosec return annotation else : return None set_attributes ( self , annotation ) Define argument attributes. Source code in argufy/argument.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def set_attributes ( self , annotation : Any ) -> None : '''Define argument attributes.''' if type ( annotation ) == bool : # Note: these store type internally if self . attributes . get ( 'default' ): self . attributes [ 'action' ] = 'store_false' else : self . attributes [ 'action' ] = 'store_true' elif type ( annotation ) == int : self . attributes [ 'type' ] = annotation self . attributes [ 'action' ] = 'append' elif type ( annotation ) == list : self . attributes [ 'type' ] = annotation self . attributes [ 'nargs' ] = self . nargs_type elif type ( annotation ) == tuple : self . attributes [ 'type' ] = annotation [ 0 ] if type ( annotation [ 1 ]) == set : self . attributes [ 'choices' ] = annotation [ 1 ] else : self . attributes [ 'type' ] = annotation","title":"Argument"},{"location":"development/argument/#argufy.argument","text":"Arguments for inspection based CLI parser.","title":"argufy.argument"},{"location":"development/argument/#argufy.argument.Argument","text":"Represent argparse arguments.","title":"Argument"},{"location":"development/argument/#argufy.argument.Argument.__init__","text":"Initialize argparse argument. Source code in argufy/argument.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , parameters : Type [ inspect . Parameter ], docstring : Type [ DocstringParam ], ) -> None : '''Initialize argparse argument.''' self . attributes : Dict [ Any , Any ] = {} self . __docstring = docstring # Define attribute defaults self . nargs_type = '+' default = parameters . default name = parameters . name . replace ( '_' , '-' ) if default == inspect . _empty : # type: ignore self . attributes [ 'name' ] = [ name ] else : self . attributes [ 'name' ] = [ '--' + name ] self . attributes [ 'default' ] = default self . set_attributes ( self . get_annotations ( parameters . annotation )) if self . attributes [ 'type' ] != bool : self . attributes [ 'metavar' ] = ( parameters . name ) . upper () if self . __docstring : self . attributes [ 'help' ] = self . __docstring . description","title":"__init__()"},{"location":"development/argument/#argufy.argument.Argument.get_annotations","text":"Get parameter types for method/function. Source code in argufy/argument.py 45 46 47 48 49 50 51 52 53 54 def get_annotations ( self , annotation : Any ) -> Any : '''Get parameter types for method/function.''' if annotation != inspect . _empty : # type: ignore return annotation elif self . __docstring and self . __docstring . type_name : # TODO: There has to be a cleaner way annotation = eval ( self . __docstring . type_name ) # nosec return annotation else : return None","title":"get_annotations()"},{"location":"development/argument/#argufy.argument.Argument.set_attributes","text":"Define argument attributes. Source code in argufy/argument.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def set_attributes ( self , annotation : Any ) -> None : '''Define argument attributes.''' if type ( annotation ) == bool : # Note: these store type internally if self . attributes . get ( 'default' ): self . attributes [ 'action' ] = 'store_false' else : self . attributes [ 'action' ] = 'store_true' elif type ( annotation ) == int : self . attributes [ 'type' ] = annotation self . attributes [ 'action' ] = 'append' elif type ( annotation ) == list : self . attributes [ 'type' ] = annotation self . attributes [ 'nargs' ] = self . nargs_type elif type ( annotation ) == tuple : self . attributes [ 'type' ] = annotation [ 0 ] if type ( annotation [ 1 ]) == set : self . attributes [ 'choices' ] = annotation [ 1 ] else : self . attributes [ 'type' ] = annotation","title":"set_attributes()"},{"location":"development/parser/","text":"Argufier is an inspection based CLI parser. Parser Provide CLI parser for function. __init__ ( self , * args , ** kwargs ) special Initialize parser. str The name of the program str The string describing the program usage str Text to display before the argument help str Text to display after the argument help list A list of ArgumentParser objects whose arguments should also be included Object A class for customizing the help output char The set of characters that prefix optional arguments None The set of characters that prefix files from which additional arguments should be read None The global default value for arguments Object The strategy for resolving conflicting optionals str Add a -h/--help option to the parser bool Allows long options to be abbreviated if the abbreviation is unambiguous Source code in argufy/parser.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , * args : str , ** kwargs : str ) -> None : '''Initialize parser. Parameters ---------- prog: str The name of the program usage: str The string describing the program usage description: str Text to display before the argument help epilog: str Text to display after the argument help parents: list A list of ArgumentParser objects whose arguments should also be included formatter_class: Object A class for customizing the help output prefix_chars: char The set of characters that prefix optional arguments fromfile_prefix_chars: None The set of characters that prefix files from which additional arguments should be read argument_default: None The global default value for arguments conflict_handler: Object The strategy for resolving conflicting optionals add_help: str Add a -h/--help option to the parser allow_abbrev: bool Allows long options to be abbreviated if the abbreviation is unambiguous ''' module = self . __get_parent_module () if module : docstring = parse ( module . __doc__ ) if not kwargs . get ( 'description' ): kwargs [ 'description' ] = docstring . short_description if 'prog' not in kwargs : kwargs [ 'prog' ] = module . __name__ . split ( '.' )[ 0 ] if 'version' in kwargs : self . version = kwargs . pop ( 'version' ) super () . __init__ ( ** kwargs ) # type: ignore add_arguments ( self , obj , parser = None ) Add arguments to parser/subparser. Source code in argufy/parser.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_arguments ( self , obj : Any , parser : Optional [ Type [ ArgumentParser ]] = None ) -> Type [ ArgumentParser ]: '''Add arguments to parser/subparser.''' if not parser : parser = self # type: ignore docstring = parse ( obj . __doc__ ) signature = inspect . signature ( obj ) for arg in signature . parameters : description = next ( ( d for d in docstring . params if d . arg_name == arg ), None ) argument = Argument ( signature . parameters [ arg ], description # type: ignore ) # print('sig:', signature.parameters[arg]) name = argument . attributes . pop ( 'name' ) parser . add_argument ( * name , ** argument . attributes ) # type: ignore return self add_commands ( self , module , exclude_prefix = [ '@' , '_' ], parser = None ) Add commands. Source code in argufy/parser.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def add_commands ( self , module : ModuleType , exclude_prefix : list = [ '@' , '_' ], parser : Optional [ Type [ ArgumentParser ]] = None , ) -> Type [ ArgumentParser ]: '''Add commands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) parameters = {} if not parser : parser = self # type: ignore if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name ) command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) # self._load_module(module, command, exclude_prefix) for name , value in inspect . getmembers ( module ): # TODO: Possible singledispatch candidate if not name . startswith ( self . __exclude_prefixes__ ): if inspect . isclass ( value ): continue elif inspect . isfunction ( value ) or inspect . ismethod ( value ): if ( module . __name__ == value . __module__ and not name . startswith ( ( ', ' . join ( self . __exclude_prefixes__ )) ) ): cmd = command . add_parser ( name . replace ( '_' , '-' ), help = docstring . short_description , ) cmd . set_defaults ( fn = value ) self . add_arguments ( value , cmd ) elif isinstance ( value , ( float , int , str , list , dict , tuple )): # TODO: Reconcile inspect parameters with dict parameters = inspect . Parameter ( name , inspect . _ParameterKind . POSITIONAL_OR_KEYWORD , default = getattr ( module , name ), annotation = inspect . _empty , # TODO: Inspect type ) description = next ( ( d for d in docstring . params if d . arg_name == name ), None , ) # print(name, parameters, description) argument = Argument ( parameters , description ) name = argument . attributes . pop ( 'name' ) parser . add_argument ( * name , ** argument . attributes ) return self add_subcommands ( self , module , exclude_prefix = [ '@' , '_' ], parser = None ) Add subcommands. Source code in argufy/parser.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def add_subcommands ( self , module : ModuleType , exclude_prefix : list = [ '@' , '_' ], parser : Optional [ Type [ ArgumentParser ]] = None , ) -> Type [ ArgumentParser ]: '''Add subcommands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) if not parser : parser = self # type: ignore if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name ) command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) subcommand = command . add_parser ( module_name . replace ( '_' , '-' ), help = docstring . short_description , ) subcommand . set_defaults ( mod = module ) self . add_commands ( module , exclude_prefix , subcommand ) return self dispatch ( self , args = None , ns = None ) Call command with arguments. Source code in argufy/parser.py 227 228 229 230 231 232 233 234 235 236 237 def dispatch ( self , args : Sequence [ str ] = None , ns : Optional [ str ] = None , ) -> Callable [[ F ], F ]: '''Call command with arguments.''' if sys . argv [ 1 :] == [] and args is None : args = [ '--help' ] arguments , namespace = self . retrieve ( args , ns ) if 'fn' in namespace : fn = vars ( namespace ) . pop ( 'fn' ) namespace = self . __set_module_arguments ( fn , namespace ) return fn ( ** vars ( namespace )) retrieve ( self , args = None , ns = None ) Retrieve values from CLI. Source code in argufy/parser.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def retrieve ( self , args : Sequence [ str ] = None , ns : Optional [ str ] = None , ) -> None : '''Retrieve values from CLI.''' main_ns , main_args = self . parse_known_args ( args , ns ) if main_args == [] and 'fn' in vars ( main_ns ): return main_args , main_ns else : if 'mod' in vars ( main_ns ): a = [] a . append ( vars ( main_ns )[ 'mod' ] . __name__ . split ( '.' )[ - 1 ]) a . append ( '--help' ) self . parse_args ( a ) return None","title":"Parser"},{"location":"development/parser/#argufy.parser","text":"Argufier is an inspection based CLI parser.","title":"argufy.parser"},{"location":"development/parser/#argufy.parser.Parser","text":"Provide CLI parser for function.","title":"Parser"},{"location":"development/parser/#argufy.parser.Parser.__init__","text":"Initialize parser. str The name of the program str The string describing the program usage str Text to display before the argument help str Text to display after the argument help list A list of ArgumentParser objects whose arguments should also be included Object A class for customizing the help output char The set of characters that prefix optional arguments None The set of characters that prefix files from which additional arguments should be read None The global default value for arguments Object The strategy for resolving conflicting optionals str Add a -h/--help option to the parser bool Allows long options to be abbreviated if the abbreviation is unambiguous Source code in argufy/parser.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def __init__ ( self , * args : str , ** kwargs : str ) -> None : '''Initialize parser. Parameters ---------- prog: str The name of the program usage: str The string describing the program usage description: str Text to display before the argument help epilog: str Text to display after the argument help parents: list A list of ArgumentParser objects whose arguments should also be included formatter_class: Object A class for customizing the help output prefix_chars: char The set of characters that prefix optional arguments fromfile_prefix_chars: None The set of characters that prefix files from which additional arguments should be read argument_default: None The global default value for arguments conflict_handler: Object The strategy for resolving conflicting optionals add_help: str Add a -h/--help option to the parser allow_abbrev: bool Allows long options to be abbreviated if the abbreviation is unambiguous ''' module = self . __get_parent_module () if module : docstring = parse ( module . __doc__ ) if not kwargs . get ( 'description' ): kwargs [ 'description' ] = docstring . short_description if 'prog' not in kwargs : kwargs [ 'prog' ] = module . __name__ . split ( '.' )[ 0 ] if 'version' in kwargs : self . version = kwargs . pop ( 'version' ) super () . __init__ ( ** kwargs ) # type: ignore","title":"__init__()"},{"location":"development/parser/#argufy.parser.Parser.add_arguments","text":"Add arguments to parser/subparser. Source code in argufy/parser.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def add_arguments ( self , obj : Any , parser : Optional [ Type [ ArgumentParser ]] = None ) -> Type [ ArgumentParser ]: '''Add arguments to parser/subparser.''' if not parser : parser = self # type: ignore docstring = parse ( obj . __doc__ ) signature = inspect . signature ( obj ) for arg in signature . parameters : description = next ( ( d for d in docstring . params if d . arg_name == arg ), None ) argument = Argument ( signature . parameters [ arg ], description # type: ignore ) # print('sig:', signature.parameters[arg]) name = argument . attributes . pop ( 'name' ) parser . add_argument ( * name , ** argument . attributes ) # type: ignore return self","title":"add_arguments()"},{"location":"development/parser/#argufy.parser.Parser.add_commands","text":"Add commands. Source code in argufy/parser.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def add_commands ( self , module : ModuleType , exclude_prefix : list = [ '@' , '_' ], parser : Optional [ Type [ ArgumentParser ]] = None , ) -> Type [ ArgumentParser ]: '''Add commands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) parameters = {} if not parser : parser = self # type: ignore if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name ) command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) # self._load_module(module, command, exclude_prefix) for name , value in inspect . getmembers ( module ): # TODO: Possible singledispatch candidate if not name . startswith ( self . __exclude_prefixes__ ): if inspect . isclass ( value ): continue elif inspect . isfunction ( value ) or inspect . ismethod ( value ): if ( module . __name__ == value . __module__ and not name . startswith ( ( ', ' . join ( self . __exclude_prefixes__ )) ) ): cmd = command . add_parser ( name . replace ( '_' , '-' ), help = docstring . short_description , ) cmd . set_defaults ( fn = value ) self . add_arguments ( value , cmd ) elif isinstance ( value , ( float , int , str , list , dict , tuple )): # TODO: Reconcile inspect parameters with dict parameters = inspect . Parameter ( name , inspect . _ParameterKind . POSITIONAL_OR_KEYWORD , default = getattr ( module , name ), annotation = inspect . _empty , # TODO: Inspect type ) description = next ( ( d for d in docstring . params if d . arg_name == name ), None , ) # print(name, parameters, description) argument = Argument ( parameters , description ) name = argument . attributes . pop ( 'name' ) parser . add_argument ( * name , ** argument . attributes ) return self","title":"add_commands()"},{"location":"development/parser/#argufy.parser.Parser.add_subcommands","text":"Add subcommands. Source code in argufy/parser.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def add_subcommands ( self , module : ModuleType , exclude_prefix : list = [ '@' , '_' ], parser : Optional [ Type [ ArgumentParser ]] = None , ) -> Type [ ArgumentParser ]: '''Add subcommands.''' module_name = module . __name__ . split ( '.' )[ - 1 ] docstring = parse ( module . __doc__ ) if not parser : parser = self # type: ignore if not any ( isinstance ( x , _SubParsersAction ) for x in parser . _actions ): parser . add_subparsers ( dest = module_name ) command = next ( ( x for x in parser . _actions if isinstance ( x , _SubParsersAction )), None , ) subcommand = command . add_parser ( module_name . replace ( '_' , '-' ), help = docstring . short_description , ) subcommand . set_defaults ( mod = module ) self . add_commands ( module , exclude_prefix , subcommand ) return self","title":"add_subcommands()"},{"location":"development/parser/#argufy.parser.Parser.dispatch","text":"Call command with arguments. Source code in argufy/parser.py 227 228 229 230 231 232 233 234 235 236 237 def dispatch ( self , args : Sequence [ str ] = None , ns : Optional [ str ] = None , ) -> Callable [[ F ], F ]: '''Call command with arguments.''' if sys . argv [ 1 :] == [] and args is None : args = [ '--help' ] arguments , namespace = self . retrieve ( args , ns ) if 'fn' in namespace : fn = vars ( namespace ) . pop ( 'fn' ) namespace = self . __set_module_arguments ( fn , namespace ) return fn ( ** vars ( namespace ))","title":"dispatch()"},{"location":"development/parser/#argufy.parser.Parser.retrieve","text":"Retrieve values from CLI. Source code in argufy/parser.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def retrieve ( self , args : Sequence [ str ] = None , ns : Optional [ str ] = None , ) -> None : '''Retrieve values from CLI.''' main_ns , main_args = self . parse_known_args ( args , ns ) if main_args == [] and 'fn' in vars ( main_ns ): return main_args , main_ns else : if 'mod' in vars ( main_ns ): a = [] a . append ( vars ( main_ns )[ 'mod' ] . __name__ . split ( '.' )[ - 1 ]) a . append ( '--help' ) self . parse_args ( a ) return None","title":"retrieve()"}]}